### Cookie和Session

Cookie是保存在浏览器上的一些数据，一般通过HTTP响应头set cookie来设置，当然也可以通过JS脚本来直接设置，Cookie是按照网站来进行组织和保存的，每一个网站都可以在浏览器中保存一些Cookie，保存好了之后，浏览器向这个网站发出的请求都会携带这些Cookie，然后后台就可以分析这些Cookie。

Session 是一个抽象的概念，用于记录一个用户在网站上的一些行为、一些状态，通过Cookie中的Session ID来标识。

### 有状态应用和无状态应用区别

1. 无状态应用：没有特殊状态的服务，各个请求对于服务器来说统一无差别处理，请求携带了所有服务端所需要的所有参数，应用的实例可以平滑迁移、水平扩展，实例之间没有显著差别
2. 有状态应用：请求必须提交到保存有其相关信息的服务器上，否则这些请求可能无法被理解

例子：

连锁火锅店打折券

无状态：打折券发放到用户手中，请求时直接拿着小票到任意一家火锅店都可以打折

有状态：打折券信息保存在火锅店，请求时上报自己的手机号，火锅店查询后如果有打折信息则可以打折。如果连锁店之间的信息没有同步，则将享受不到打折优惠

#### 数据有状态应用

1. **数据依赖**：运行过程中依赖本地数据
2. **数据持久**：升级前后数据不能丢失
3. **依赖关系**：服务实例之间存在主从、主备等依赖关系，因此每个实例有唯一的 ID 标识；

### Kubernetes 上部署有状态的云原生应用

#### 共享存储

将 Kubernetes 集群与 Samba、NFS 或 GlusterFS 等传统的存储基础设施集成在一起，这种方法可以轻松扩展到基于云的共享文件系统

计算层、存储层解耦，无需定义节点亲和性，但不适合高I/O的场景

**应用场景** 内容管理系统、机器学习系统和数字资产管理系统等

#### StatefulSet

StatefulSet 中的每个 Pod 都有一个对应的持久卷声明（PVC），该声明遵循相似的命名约定。当 Pod 终止并在其他节点上重新调度时，Kubernetes 控制器将确保 Pod 与同一 PVC 关联，以此来保证集群的状态。

#### Operator

Operator 通过  CustomResourceDefinition（CRD）为服务定义了新的资源对象，同时通过自定义控制器来保证应用处于预期状态。

Operator 的工作流程可以抽象为以下三个步骤：

> 1. Observe 通过Kubernetes API 观察目标对象的状态
> 2. Analize 分析当前状态与期望状态的差别
> 3. Act 执行编排操作，将当前状态调整为期望状态

